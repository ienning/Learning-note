[TOC]

# 操作系统

## 第1章 计算机系统概述

### 1.1 操作系统的基本概念

#### 1.1.1 操作系统的概念

操作系统是计算机系统中最基本的系统软件。操作系统是控制和管理整个计算机系统的硬件与软件资源，合理地组织/调度计算机的工作和资源的分配，进而为用户和其它软件提供方便接口与环境的程序集合。

#### 1.1.2 操作系统的特征

**1. 并发**

并发是，两个或多个事件同一时间间隔发生。操作系统引入进程的目的是为了使程序并发执行。

**2. 共享**

即资源共享，是指操作系统中的资源能够共享给并发执行的进程共同使用。共享一般分为两种：

1. 互斥共享
   - 像打印机，磁带机这些，虽然可以提供给多个进程使用，但是再一段时间内只能让一个进程使用，不然打印或者记录时候，同时写入会造成混淆。
2. 同时访问共享
   - 同时访问共享通常一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。

**3. 虚拟**

虚拟是指把一个物理上实体变为若干逻辑上的对应物。例如可以利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU，成为虚拟处理器。

**4. 异步**

多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是程序的异步性。

#### 1.1.3 操作系统的目标和功能

目的：给多道程序提供良好的运行环境，还需要为用户提供接口，和可以扩充机器提升利用率。

**给多道程序提供良好的运行环境**

功能：处理及管理、存储器管理、设备管理和文件管理

**还需要为用户提供接口**

功能：分类命令接口和系统调用

- 命令接口：根据作业不同：
  - 联机命令接口
  - 脱机命令接口
- 系统调用

**可以扩充机器**



#### 1.1.4 习题

**1. 选择题**

- 1-5：CDDDB
- 6-10：CBBCA
- 11-15：AA~~C~~D**C**D
- 16-18：DAD

### 1.2 操作系统的特征

#### 1.2.1 手工操作阶段（此阶段无操作系统）

 突出缺点：

1. 用户独占全机，资源利用率低
2. CPU等待手工操作，CPU利用不充分。

#### 1.2.2 批处理阶段（操作系统开始出现）

1. 单道批处理系统
   - 自动性
   - 顺序性
   - 单道性
2. 多道批处理系统：多道、宏观上并行、微观上串行

#### 1.2.3 分时操作系统

分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。

- 同时性：多个终端用户同时使用一台计算机
- 交互性：
- 独立性：用户独立操作，互不干扰
- 及时性：用户请求能在很短时间内获得响应

#### 1.2.4 实时操作系统

为了能再某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。

#### 1.2.5 网络操作系统和分布式计算机系统

网络操作系统把计算机网络的各台计算机有机地结合起来。

分布式计算机系统由多台计算机组成并满足下列条件：

1. 系统中任意两台计算通过通信方式交换信息。
2. 系统中每台计算机都有相同地位，没有主从之分
3. 每台计算机资源为所有用户共享
4. 系统中任意台计算机都可以构成一个子系统，并且还能重构。
5. 任何工作都能分布在机台计算机上，由它们并行工作、协同完成。

#### 1.2.6 个人计算机操作系统

个人计算机操作系统是目前使用最广泛地操作系统，它广泛应用于文字处理、电子表格、游戏中，比如Windows、Linux和Macintosh等。

#### 1.2.7 习题

**1. 选择题**

- 1-5：DDCBB
- 6-10：CBDCB
- 11-16：CBBACDAD~~B~~C

### 1.3 操作系统的目标和功能

#### 1.3.1 处理器运行模式

CPU执行两种不同性质地程序：

1. 操作系统内核程序
2. 用户自编程序

操作系统内核功能包括：

**1.时钟管理**

时钟是最重要的设备。

功能：

1. 计时，通过时钟管理为用户提供给标准的系统时间
2. 通过时钟中断的管理，可以实现进程的切换
   1. 分时操作系统采用时间片轮转调度
   2. 实施系统按照截止时间控制运行
   3. 批处理系统中，通过时钟管理衡量一个作业的运行程度等。

**2. 中断机制**

初衷是提高多道程序运行环境中CPU的利用率。逐步发展后成为操作系统各项操作的基础。

**3. 原语**

按层次设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。特点如下：

1. 处于操作系统的最底层，最接近硬件的部分
2. 具有原子性，操作只能一气呵成
3. 运行时间段，调用频繁

定义原语的直接方法是关闭中断。

**4. 系统控制的数据结构及处理**

系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了有效管理，常见的三种操作：

1. 进程管理：进程状态管理、进程调度和分派、创建和撤销进程控制块等。
2. 存储器管理：存储器的空间分配和回收、内存信息保护程序、代码兑换程序等。
3. 设备管理。缓冲区管理，设备分配和回收。

#### 1.3.2 中断和异常的概念

用户程序想从用户态中调用核心态，需要通过中断进行响应切换。某个程序占据的资源的释放需要通过中断实现。

**1. 中断和异常的定义**

中断（Interruption）也称为外中断，来自CPU执行指令外部的事件，通常用于信息输入/输出。

异常（Exception）也称为内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、

运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，需要立即处理。

**2. 中断和异常的分类**

![Interruption](.\System\Interruption.png)

**3. 中断和异常的处理过程**



#### 1.3.3系统调用

系统调用是指用户程序再程序中调用操作系统锁提供的一些子功能，系统调用可以称为的公共子程序。

通常由以下几种分类：

- 设备管理：完成设备的请求或释放，以及设备启动等功能。
- 文件管理：完成文件的读、写、创建和删除等功能。
- 进程控制：完成进程的创建、撤销、阻塞及唤醒功能。
- 进程通信：完成进程之间的消息传递或信号传递等功能。
- 内存管理：完成内存的分配、回收以及获取作业占用内存大小及始地址等功能。

常见的特权指令：

- 对I/O设备操作的指令
- 有关访问程序状态的指令
- 存取特殊寄存器的指令
- 其他指令

用户态转向核心态的例子：

1. 用户程序需要操作系统的服务，即系统调用
2. 发生了一次中断。
3. 用户程序中产生了一个错误状态。
4. 用户程序中企图执行一条特权指令。
5. 从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。

若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是再用户态使用的，所以它不可能是特权指令。

#### 1.3.4 习题

**1. 选择题**

1-5：AC**C**C~~C~~D

6-10：D~~C~~ACA**B**

11-15：AC**CD**D

16-20：BA~~A~~C**~~A~~**BB

21-25：**D~~A~~B~~B~~C**AC

26-29：~~A~~DCD**B**



### 1.4 操作系统结构

可以使用分层法将操作系统分成若干层，最底层是硬件，最高层为用户接口，每一层之只能调用紧邻它的低层的功能和服务（类似于网络层次划分一样）

**操作系统结构模块化**

模块化，是将操作系统细分为几个模块，每个模块下有子模块。

- 进程管理：子模块从进程控制到进程调度等
- 存储器管理：内存分配到内存保护等
- 文件管理：从磁盘管理到目录管理等

衡量模块的独立性有两个标准：

1. 内聚性：模块内各部分的联系紧密程度，内聚性越高，模块独立性越好。
2. 耦合度：模块之间相互联系和相互影响的程度，耦合度越低，模块独立性越好。

优点：

1. 提高了操作系统设计的正确性、可理解性和可维护性
2. 增强了操作系统的可适应性
3. 加速了操作系统的开发过程

缺点：

1. 模块之间的接口规定比较难以满足对接口的实际需求
2. 各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。

**内核**

宏内核：称之为单内核或大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态

微内核：微内核表示操作系统中将部分非核心功能迁移到用户空间，方便拓展新功能，基本不用修改内核

外核：任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。

#### 1.4.4 习题

**1. 选择题**

### 1.5 操作系统引导

过程如下：

1. 激活CPU，激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS的第一条指令，开始执行BIOS的指令
2. 硬件自检
3. 加载带有操作系统的硬盘
4. 加载主引导记录MBR，用于告诉CPU去哪个硬盘哪个主分区找操作系统
5. 扫描硬盘分区，并加载硬盘活动分区
6. 加载分区引导记录PBR
7. 加载启动管理器
8. 加载操作系统

#### 1.5.4 习题

**1. 选择题**

### 1.6 虚拟机

#### 1.6.1 虚拟机基本概念

虚拟机是一台逻辑计算机，利用虚拟化技术，通过隐藏特定计算机平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。虚拟化方法有两类：

**第一类虚拟机管理程序**

第一类虚拟机管理程序类似于操作系统，因为它是唯一一个运行在最高特权的程序，它在裸机上具备多道程序功能，向上层提供若干台虚拟机，这些虚拟机是逻辑硬件的精确复制品。

**第二类虚拟机管理程序**

第二类虚拟机管理程序是依赖于Windows、Linux等操作系统进行资源分配，类似于一个普通进程，但是能够伪装成具有CPU和各种设备的完整计算机。VMWare Workstation就是属于第二类虚拟机管理程序。

#### 1.6.4 习题

**1. 选择题**

## 第2章 进程与线程

### 2.1 进程与线程

#### 2.1.1 进程的概念和特征

**1. 进程的概念**

在多道程序中，如果要并行执行多个程序，那么就会失去封闭性，，并具有间断性及不可再现性的特征。引入进程是为了更好描述和控制程序的并发执行，实现操作系统的并行性和共享性。

控制进程主要是通过进程控制块（PCB）来进行控制，所谓的创建进程，实质是创建进程实体中的PCB。进程实体（也称之为进程映像）由程序段、相关数据段和PCB三部分组成。进程映像是静态的，进程是动态的。

PCB是进程存在的唯一标识

#### 2.1.2 进程的状态与转换

1. 运行态

2. 就绪态

3. 阻塞态

4. 创建态

5. 结束态

   创建态->就绪态<=>运行态->结束态；其中阻塞态是可以从运行态到阻塞态，阻塞态到就绪态

#### 2.1.3 进程的组织

**1.进程控制块**

进程创建时，系统为它创建一个PCB，该结构是常驻内存的

进程执行时，系统通过其PCB了解进程执行情况

进程结束时，系统回收其PCB，该进程随之消亡

| 进程描述信息      | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| ----------------- | ------------------ | ------------ | -------------- |
| 进程标识符（PID） | 进程当前状态       | 代码段指针   | 通用寄存器值   |
| 用户标识符（UID） | 进程优先级         | 数据段指针   | 地址寄存器值   |
|                   | 代码运行进入地址   | 堆栈段指针   | 控制寄存器值   |
|                   | 程序的外存地址     | 文件描述符   | 标志寄存器值   |
|                   | 进入内存时间       | 键盘         | 状态字         |
|                   | 处理机占用时间     | 鼠标         |                |
|                   | 信号量使用         |              |                |

#### 2.1.4 进程控制

原语：进程控制用的程序段称之为原语，特点是执行期间不允许中断，是一个不可分割的基本单位。

**1. 进程的创建**

允许一个进程创建另外一个进程，子进程使用的是父进程的资源，子进程释放时，会返还资源给父进程；父进程释放时，会释放所有子进程。进程创建过程中是不能中断的，是一个原语。

创建进程过程（原语）：

1. 为创建进程分配一个唯一的进程标识符，申请分配一个空白的PCB（PCB是有限的），若PCB申请失败，则创建失败
2. 为进程分配其运行的所需资源。如果所需资源不足，则不是创建失败，而是处于创建态中，等待资源
3. 初始化PCB，主要包括初始化标识信息，初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行

**2. 进程的终止**

引起进程终止的主要原因：

1. 正常结束，指进程正常完成任务，准备退出
2. 异常结束，指进程运行时，发生了某种异常事件，使程序无法继续正常运行。
3. 外界干预，指进程应外界的请求而终止

**3. 进程的阻塞和唤醒**

正在执行的进程因为某些期待的事件没有发生（例如：请求系统资源失败，等待某种操作的完成等），便通过调用阻塞原语，使自己运行态变为阻塞态。

阻塞原语：

1. 找到要被阻塞进程的标识号对应的PCB
2. 若该进程为运行态，则保护现场，将其状态转为阻塞态，停止运行
3. 把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。

当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程调用唤醒原语。

唤醒原语：

1. 在该事件的等待队列中找到相应进程的PCB
2. 将其从等待队列中移出，并置其状态为就绪态
3. 把该PCB插入就绪队列，等待调度程序调度。

#### 2.1.5 进程的通信

进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级方式是指以较高的效率传输大量数据的通信方式。

**1. 共享存储**

通过共享空间，进行通讯。通过对共享空间进行读写实现进程之间信息交换。

- 低级方式：基于数据结构共享
- 高级方式：基于存储区共享

**2. 消息传递**

以格式化的消息为单位。通过操作系统提供的消息传递方法实现通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

- 直接通信：发送进程直接把消息发送到接收进程，并将它挂在接收进程的消息缓存队列上，接收进程从消息缓冲队列中取得消息
- 间接通信：发送进程将消息发送到中间实体中，接收进程从中间实体中获取消息。中间实体类似于信箱的功能。

**3. 管道通信**

使用一个共享文件实现一个读进程和一个写进程之间的通讯，称之为管道。

管道克服通讯的两个问题：

1. 限制管道大小可以克服文件一直增长，防止校验变得过长
2. 读比写快，如果管道数据被读取完后，会清空，read会被堵塞，这样解决了read调用返回文件结束的问题。

克服通讯两个问题后，管道只能采用半双工通信。某一个时刻只能单向传输。

#### 2.1.6 线程和多线程模型

**1. 线程的概念**

引入进程是为了提升处理机的使用效率，多道程序并发执行，提高资源利用率和系统吞吐量。而引入线程的目的是减小程序程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

线程是进程中的一个实体，是系统独立调度和分派的基本单位。

线程有三种基本状态：就绪、阻塞和运行。

**2. 线程与进程的比较**

1. 调度：引入线程的操作系统中，线程是独立调度的最小基本单位。
2. 并发性：进程和线程都可以并发执行，所以能够更好提升系统的资源利用率和系统的吞吐量。
3. 拥有资源：进程是系统中拥有资源的基本单位，线程不拥有资源，但是线程可以使用和访问所属的进程的资源。
4. 独立性：每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其它进程访问。某进程中的线程对其他进程不可见。同一进程中的不同线程是为了提升系统的并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。
5. 系统开销：进程的创建，切换和销毁的开销都是大于线程的。
6. 支持多处理机系统：对于单线程进程，不管有多少处理机，进程只能运行在一个处理机上，但是对于多线程进程，可以将进程的多个线程分配到多个处理机上执行。

**3. 线程的属性**

1. 线程是一个轻量的实体，它不拥有系统资源，但是每个线程都拥有线程标识符和一个线程控制块
2. 不同线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建生成不同的线程。
3. 同一个进程中的各个线程共享该进程所拥有的资源。
4. 线程是处理机独立调度的基本单位，多个线程可以并发执行的。
5. 一个线程被创建后，便开始了它的生命周期，直至终止。

**4. 线程的状态与转换**

1. 执行状态：线程已获得处理机而正在运行
2. 就绪状态：线程已具备各种执行条件，只需获得CPU便可立即执行
3. 阻塞状态：线程在执行中因某事件受阻而处于暂停状态。

线程这三种基本状态转变与进程基本状态之间的转换是一样的。

**5. 线程的组织与控制**

1. 线程与进程类似，也包含一个线程控制块，用于记录控制和管理线程的信息；通常包括：
   1. 线程标识符
   2. 一组寄存器，包括程序计数器、状态寄存器和通用寄存器
   3. 线程运行状态，用于描述线程正处于何种状态
   4. 优先级
   5. 线程专有存储区域，线程切换时用于保护现场等
   6. 堆栈指针，用于过程调用时保存局部变量和返回地址等。
2. 线程的创建：线程也具有生命周期，由创建而产生，由调度而执行，由终止而消亡。在操作系统中有用于创建线程和终止线程的系统调用。进程中存在创建线程的线程
3. 线程的终止：线程任务结束后或执行中出现异常而被强制终止时，由终止线程调用相应的函数执行终止函数。线程被终止后不会立即释放占用的资源，只有在进程中其它线程执行了分离函数后，被终止的线程才与资源分离，所以被终止的线程但是没有释放占用资源的线程，可以被其它线程调用，以使被终止线程重新恢复执行。

**6. 线程的实现方式**

线程的实现方式分为两类：用户级线程和内核级线程。内核级线程又称内核支持的线程。

（1）用户级线程（ULT）

有关线程管理（创建，撤销和切换等）的所有工作都由应用程序在用户空间中完成，内核意识不到线程的存在。

设置用户级线程的系统，其调度任然以进程为单位。会导致，如果某个进程中的线程比较多，分给每个线程的时间就比较少了。

优点：

1. 线程切换不需要转换到内核空间，节省模式切换的开销
2. 调度算法可以是进程专用的，不同进程可根据自身的需要，对自己线程选择使用不同的算法。
3. 用户级线程的实现与操作系统平台无关，对线程管理的代码属于用户程序的一部分。

缺点：

1. 系统调用阻塞问题，当一个线程调用系统调用时，这个进程下的所有线程都被阻塞。
2. 不能发挥多处理机的优势，内核每次分配给一个进程仅有一个CPU，因此进程中仅有一个线程能执行

1. 内核级线程

（2）内核级线程（KLT）

有关线程管理（创建，撤销和切换等）的所有工作都由内核空间中实现的，称为内核级线程。内核空间为每个内核级线程设置一个线程块，用于感知该线程进而控制该线程。

优点：

1. 能发挥多处理机优势
2. 如果进程中的一个线程阻塞，可以调用某个该进程中的别的线程占用处理机，也可以运行其他进程的线程
3. 内核支持比较小的数据结构和堆栈，切换比较快，开销小。
4. 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率

缺点：

1. 同一个进程中的线程切换，需要从用户态转为内核态进行，系统开销较大。这是因为用户进程的线程在用户态进行，而线程调度和管理是在内核实现的。

（3）组合方式

某些系统，通过内核线程和用户线程组合方式，一些内核级线程对应多个用户级线程，用户级线程通过时分复用内核线程实现的。同一个进程的多个线程可以同时在多处理机上并行执行，且阻塞一个线程时不需要将整个进程阻塞，所以能够克服各自的不足

线程库是提供线程创建和管理线程的API，主要两种

1. 用户空间提供一个没有内核支持的库，所有代码和数据都位于用户空间，其实就是调用用户空间中的某个函数。
2. 实现由操作系统直接支持的内核级的一个库。库内代码和数据结构位于内核空间。

**7. 多线程模型**

用户级线程和内核级线程连接方式不同，从而形成三种不同的多线程模型：

1. 多对一模型：多个用户级线程映射到一个内核级线程，效率高，但是一个线程被阻塞，整个进程会被阻塞、
2. 一对一模型：每个用户级线程映射到一个内核级线程，并发强，但是每创建一个用户线程，都需要创建内核线程，开销大。
3. 多对多模型：将n个用户线程映射到m个内核级线程（n>=m）；拥有前面两种的优点。

#### 2.1.7 小结

### 2.2 处理机调度

#### 2.2.1 调度的概念 

**1. 调度的基本概念**

处理机调度是对处理机进行分配，从就绪队列中按照一定算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

**2. 调度的层次**

一个作业从提交到完成往往经历以下三级调度

1. 高级调度（作业调度）：从外存中将后备队列中取出一个多几个作业，创建进程，放入就绪队列中
2. 中级调度（内存调度）：将暂时不能运行的进程调度到外存中，称为挂起态。将具备运行条件且内存空闲，将处于挂起的进程调回内存。修改为就绪态。
   1. 目的：提升内存利用率和系统吞吐量
3. 低级调度（进程调度）：按照某种算法从就绪队列中选取一个进程，将处理机分配给它。

**3. 三级调度的关系**

1. 作业调度为进程调度做准备，进程调度使进程活动起来
2. 中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间
3. 作业调度次数少，中间调度次数略多，进程调度频率最高
4. 进程调度使最基本的，不可或缺

#### 2.2.2 调度的目标

1. CPU利用率：CPU利用率 = CPU有效时间/(CPU有效时间+CPU空闲等待时间)
2. 系统吞吐量：表示单位时间内CPU完成的作业数量
3. 周转时间：
   1. 周转时间 = 作业完成时间 - 作业提交时间
   2. 平均周转时间 = （作业一的周转时间 + 作业二的周转时间 + ... + 作业n的周转时间）/n
4. 等待时间：指进程处于等处理机的时间之和
5. 响应时间：指从用户提交请求到系统首次响应所用的时间。

#### 2.2.3 调度的实现

**1. 调度程序（调度器）**

调度程序通常由三部分组成：

1. 排队器：将所有进程就绪进程按照一定的策略排成一个或多个队列，以便调度程序选择。每当有一个进程转变为就绪状态，排队器就将它插入到相应的就绪队列中
2. 分排器：按照调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程
3. 上下文切换器：在对处理机进程切换时，会对两对上下文的切换操作：
   1. 第一对，将当前进程的上下文保存到其PCB中，再装入分配程序的上下文，以便分配程序运行
   2. 第二对，移出分配程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器

**2. 调度的时机、切换与过程**

现代操作系统中，不能进行进程的调度和切换的情况，需要等下述操作结束才能进行调度和切换：

1. 在处理中断的过程中
2. 进程在操作系统**内核**临界区中
3. 其他需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作

应该进行进程调度与切换的情况：

1. 发生引起调度条件且当前进程无法继续运行下去时，可以马上调度和切换。若操作系统只在这种情况下进行进程调度，则是非剥夺调度
2. 中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度和切换。若操作系统支持这种情况下进行进程调度，则是剥夺调度

**3. 进程调度方式**

1. 非抢占调度方式，又称非剥夺方式
   1. 优点：实现简单、系统开销小，适用于大多数的批处理系统，但不能用于分时系统和大多数实时系统
2. 抢占调度方式，又称剥夺方式	
   1. 优点：提升系统吞吐率和响应效率。

**4. 闲逛进程**

在进程切换时，如果系统没有就绪进程，就会调度闲逛进程（idle）运行，如果没有其他进程就绪，该进程就会一直运行，并在执行过程中测试中断，不需要CPU之外的资源。

**5. 两种线程的调度**

1. 用户级线程调度：内核不知道线程存在，所以内存选择一个进程，给予时间控制。由进程的调度程序决定哪个线程运行。
2. 内户级线程调度：内核选择一个特定线程运行。

用户级线程的线程切换在同一进程中进程，仅需少量的机器指令

内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟



#### 2.2.4 典型的调度算法

**1. 先来先服务（FCFS）调度算法**

FCFS调度算法即可用于作业调度，又可用于进程调度。

在作业调度中：从后备队列中选择最先进入队列的一个或几个作业调入内存中，分配必要的资源，创建进程并放入就绪队列

在进程调度中：从就绪队列中选择最先进入的该队列的进程，将处理机分配给它

特点：

1. 简答但是效率低，对长作业有利，对短作业不利，对CPU繁忙型

**2. 短作业优先（SJF）调度算法**

短作业优先（SJF）调度算法中，是指对短作业（进程）优先调度。

特点：

1. 对长作业不利，存在长作业长时间无法被调度，出现饥饿现象
2. 没有考虑
3. 平均等待时间、平均周转时间最少

**3. 优先级调度算法**

优先级调度即可用于作业调度，又可用于进程调度

根据新的更高优先级进程能否抢占正在执行的进程，分为：

1. 非抢占式优先级调度算法
2. 抢占式优先级调度算法

而根据进程创建后其优先级是否可以改变，分为：

1. 静态优先级：优先级在创建进程时确定，且在进程的整个运行期间保持不变
2. 动态优先级：在进程运行过程中，根据进程情况的变化进程动态调整优先级

一般进程优先级参考原则：

1. 系统进程 > 用户进程
2. 交互型进程 > 非交互型进程
3. I/O型进程 > 计算型进程

**4. 高响应比优先调度算法**

高响应比优先调度算法主要用于作业调度。

响应比公式：响应比R = （等待时间+要求服务时间）/要求服务时间

特点：

1. 对于长作业，作业的响应比随着等待时间增加而提高，当其等待时间足够长时，也可获得处理机，克服“饥饿”现象

**5. 时间片轮转调度算法**

时间片轮转调度算法主要适用于分时系统，调度程序每次取出就绪队列中第一个进程，然后执行一个时间片周期，使用完后，如果进程还没有完成，会被释放（被剥夺）处理机给下一个进程

时间片长短由以下因素确定：

1. 系统的响应时间
2. 就绪队列中的进程数目
3. 系统的处理能力

**6. 多级队列调度算法**

通过设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列。每个队列可实施不同的调度算法。

**7. 多级反馈队列调度算法**

多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。实现思想：

1. 设置多个就绪队列，并为每个队列赋予不同优先级，第1级队列优先级最高，第二级队列的优先级次之，其余队列优先级逐个降低
2. 赋予各个队列的进程运行时间片的大小各不相同。
3. 每个队列采用FCFS算法，首先放入第1级队列末尾，如果在一个运行时间片后还没未执行完，就转移到下一队列中，以此类推
4. 按队列优先级调度。仅当第1级队列为空，才调度第2级队列中的进程运行。如果在执行i级队列中，又有新进程进入任一优先级较高的队列，此时立即把正在运行的进程放回i级队列的末尾，而把处理机分配给新的高优先级队列进程

优点：

1. 短终端型作业用户：短作业优先
2. 短批处理作业用户：周转时间较短
3. 长批处理作业用户：经过前面几个队列得到充分执行，不会长期得不到处理

#### 2.2.5 进程切换

**1. 上下文切换**

切换CPU到另一进程需要保存当前状态并恢复另一个进程的状态，这个任务成为上下文切换。上下文是指某一时刻CPU寄存器和程序计数器的内容。

上下文切换流程：

1. 挂起一个进程，保存CPU上下文，保存程序计数器和其他寄存器
2. 更新PCB信息
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
4. 选择另一个进程执行，并更新其PCB
5. 跳转到新进程PCB中的程序计数器所指向的位置执行
6. 恢复处理机上下文

**上下文切换的消耗**

上下文切换是计算密集型操作。有些处理器提供多组寄存器组，上下文切换时候只需要改变当前寄存器组的指针

**3. 上下文切换与模式切换**

模式切换和上下文切换是不同的，模式切换时，CPU逻辑上可能还执行同一进程。用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态

### 2.3 同步与互斥

#### 2.3.1 同步与互斥的基本概念

**1. 临界资源**

一次仅允许一个进程使用的资源称为临界资源。

对于临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区，可以把临界资源的访问过程分成4个部分：

1. 进入区：用于检查可否进入临界区，检查成功会设置正在访问临界区的标志，以阻止其它进程同时进入临界区
2. 临界区：进程中访问临界资源的那段代码，又称为临界段
3. 退出区： 将正在访问的临界区的标志清除
4. 剩余区：代码中的其余部分。

**2. 同步**

同步也称为直接制约关系，指为完成某个人物而建立的多个进程，这些进程因为在某些位置需要别的进程配合工作，产生了次序关系，需要进行制约。

**3. 互斥**

互斥也称为间接制约关系，当一个进程进入临界区，另一个进程必须等待，知道进入临界区的进程退出才能进入。

同步机制准守的准则：

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

#### 2.3.2 实现临界区互斥的基本方法

**1. 软件实现方法**

1. 算法1：单标志法。用一个公共变量turn标志拿个进程可以进入临界区。违背了“空闲让进”
2. 算法2：双标志法先检查。进程访问前检查临界资源是否被访问，若被访问中，该进程需要等待；否则自己进入。
   1. 优点：不用交替可连续进入
   2. 缺点：存在进程同时进入的可能。违背“忙则等待”
3. 算法3：双标志法后检查，先将自己标志置为true，再检查对方的状态标志
   1. 优点：不用交替可连续进入
   2. 缺点：会造成饥饿。
4. 算法四：Peterson's Algorithm：算法3的基础上再加入算法1中turn标志，解决饥饿问题

**2. 硬件实现方法**

通过硬件支持实现临界区段问题的方法称为低级方法，或称元方法

1. 中断屏蔽法

   防止其他进程进入临界区可以使用关中断。CPU只在发送中断时引起进程切换，因此屏蔽中断可以保证运行的进程让临界区代码顺利地执行完。

   限制了处理机交替执行程序能力，执行效率会显著降低。

2. 硬件指令法

   TestAndSet指令：这指令是原子操作，功能是读出指定标志后把该标志设置为真。

   Swap指令：这指令功能是交换两字的内容。

硬件方法优点：是用于任意数量的进程，而不管是单处理机还是多处理机，简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。

硬件方法缺点：进程等待进入临界区时需要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，导致“饥饿现象”。

#### 2.3.3 互斥锁

```C
// 都死原子操作
acquire() {
	while(!availabel)
		;					// 忙等待
		available = false	// 获得锁
}

release() {
	available = true;		// 释放锁
}
```



#### 2.3.4 信号量

信号量用于解决互斥和同步问题，只能被两个标准的原语wait(S)和signal(S)访问，可以记为“P操作”和“V操作”

原语通常由硬件实现

**1. 整型信号量**

```C
// 整型信号量被定义为一个用于表示资源数量的整型量S，wait和signal操作可以如下描述
wait(S) {
	while(S <= 0);
	S = S-1;
}

signal(S) {
	S = S+1;
}

// 该机制并未遵循让权等待准则，而是让进程处于忙等待
```



**2. 记录型信号量**

```c
typedef struct {
	int value;
	struct process *L;
} semaphore;

void wait(semaphore S) {
	S.value--;
	if(S.value<0) {
		add this process to S.L;
		block(S.L);
	}
}

void signal(semaphore S) {	// 释放资源
	S.value++;
	if(S.value <=0) {
		remove a process P from S.L;
		wakeup(P);
	}
}
```



**3. 利用信号量实现同步**

**4. 利用信号量实现进程互斥**

**5. 利用信号量实现前驱关系**

**6. 分析进程同步和互斥问题的方法步骤**

1. 关系分析，找到问题中的进程数，分析他们之间的同步和互斥关系。
2. 整理思路
3. 设置信号量

#### 2.3.5 管程

**1. 管程定义**

在信号量机制中， 每个方位临界资源的进程需要自备同步的PV操作，大量分散的同步操作容易带来麻烦，且容易因同步问题造成死锁。所以管程诞生了，用于管理进程同步。

管程组成：

1. 管程的名称
2. 局部于管程内部的共享数据结果说明
3. 对该数据结构进行操作的一组过程（或函数）
4. 对局部于管程内部的共享数据设置初始值的语句。

**2. 条件变量**

当一个进程进入管程后被堵塞，如果该进程一直不释放管程，那么其他进程无法进入管程。可以将阻塞原因定义为条件变量condition，每个条件变量保存了一个等待队列，用于记录因该条件变量而堵塞的所有进程。

x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程，其它进程可以使用该管程

x.signal：x对应的条件发送了变化，则调用x.signal，唤醒一个因x条件而堵塞的进程。

条件变量和信号量的比较：

- 相似点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒
- 不同点：条件变量没有值，仅实现了排队等待功能，而信号量有值反映了资源剩余数，而在管程中剩余资源数用共享数据结构记录。

#### 2.3.6 经典同步问题

**1. 生产者消费者**

**2. 读者-写者问题**

**3. 哲学家就餐问题**

**4. 吸烟者问题**

### 2.4 死锁

#### 2.4.1 死锁的概念

**1. 死锁的定义**

死锁是指多个进程因竞争资源而造成一种僵局（互相等待），如果外力作用，这些进程无法向前推进。

**2. 死锁产生的原因**

1. 系统资源的竞争
2. 进程推进顺序非法
3. 死锁产生的必要条件
   1. 互斥条件
   2. 不剥夺条件
   3. 请求并保持条件
   4. 循环等待条件

**3. 死锁的处理策略**

设法破坏死锁的4个必要条件之一或允许死锁产生，但死锁发送时，能够检测出死锁并有能力恢复

1. 死锁预防，设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个
2. 避免死锁，在资源的分配过程中，用某些方法阻止系统进入不安全状态。
3. 死锁的检测及解除



|          | 资源分配策略                                       | 各种可能模式                             | 主要优点                                     | 主要缺点                                                   |
| -------- | -------------------------------------------------- | ---------------------------------------- | -------------------------------------------- | ---------------------------------------------------------- |
| 死锁预防 | 保守，宁可资源闲置                                 | 一次请求所有资源，资源剥夺，资源按序分配 | 是用于突发式处理的进程，不必进行剥夺         | 效率低，进程初始化时间延长；剥夺次数过多；不灵活申请新资源 |
| 避免死锁 | 是”预防“和”检测“的折中（在运行时判断是否可能死锁） | 寻找可能得安全允许顺序                   | 不必进行剥夺                                 | 必须知道将来的资源需求；进程不能被长时间阻塞               |
| 死锁检测 | 宽松，只要允许就分配资源                           | 定期检查死锁是否已经发生                 | 不延长进程初始化时间，允许对死锁进行现场处理 | 通过剥夺解除死锁，造成损失                                 |



#### 2.4.2 死锁预防

**1. 破坏互斥条件**

让某些资源共享使用，不过有些无法被共享

**2. 破坏不剥夺条件**

请求获取不到新资源时，释放已经保持的所有资源，重新申请。对能够轻松现场恢复的友好，但是像打印机之类不行。实现复杂

**3. 破坏请求并保持条件**

进程运行前一次申领完所有资源，系统资源容易浪费，还容易导致饥饿现象。

**4. 破坏循环等待条件**

采用顺序资源分配法。但是如果有拓展进资源时候，又得重新处理排序。

#### 2.4.3 避免死锁

**1. 系统安全状态**

分配资源前，计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，可以分配，否则不分配让进程进入等待。

系统能够找到一个安全的顺序让每个进程分配所需的资源进行顺序完成。

**2. 银行家算法**

把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家带宽。操作系统按照银行家指定的规则为进程分配资源。

1. 数据结构描述：
   1. 可利用资源向量Available：含有m个元素的数组，每个元素代表一类可用的资源数目
   2. 最大需求矩阵Max，nxm矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求
   3. 分配矩阵 Allocation：nxm矩阵，定义系统中每类资源当前已分配给每个进程的资源数。
   4. 需求矩阵Need：nxm矩阵，表示每个进程接下来最多还需要多少资源。
      1. Need = Max - Allocation
2. 银行家算法描述：设Requesti 是进程Pi的请求向量，Requesti[j]=K表示进程Pi需要j类资源K个。步骤如下：
   1. 若Requesti[j] <= Need[i, j]，则转向步骤2；否则出错，因为它所需资源超过它所宣布的最大值
   2. 若Requesti[j] <= Available[j]，则转向步骤3；否则表示尚无足够资源，Pi须等待
   3. 系统试探着把资源分配给进程Pi，并修改上面所说的数据结构中的数值
   4. 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。
3. 安全性算法：设置工作向量Work，有m个元素，表示系统重的剩余可用资源数目。在执行安全性算法开始时，Work=Available
   1. 初始时安全序列为空
   2. 从Need矩阵中找出符合下面条件的行：该行对应的进程不在安全序列中，而且该行小于等于Work向量，找到后把对应的进程加入安全序列；若找不到执行步骤4
   3. 进程Pi进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，因此应执行Work=Work+Allocation[i]，其中Allocation[i]表示进程Pi代表的在Allocation矩阵中对应的行，返回步骤2
   4. 若此时安全序列中已有所有进程，则系统处于安全状态，否则系统处于不安全状态

**3. 安全性算法举例**

**4. 银行家算法举例**



#### 2.4.4 死锁检测和解除

**1. 资源分配图**

**2. 死锁定理**

**3. 死锁解除**

死锁解除主要方法：

1. 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配各其它死锁进程。但要防止被挂起的进程长时间得不到资源而处于资源匮乏状态。
2. 撤销进程法。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按照进程优先级和撤销进程代价的高低进行
3. 进程回退法。让一（或多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非剥夺。要求系统保持进程的历史信息，设置还原点。

## 第3章 内存管理

### 3.1 内存管理概念

### 3.2 虚拟内存管理

## 第4章 文件管理

### 4.1 文件系统基础

### 4.2 目录

### 4.3 文件系统



## 第5章 输入/输出管理

### 5.1 I/O管理概述

### 5.2 设备独立性软件

### 5.3磁盘和固态硬盘

