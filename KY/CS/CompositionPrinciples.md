[TOC]

# 计组原理

## 第一章

### 1.1 计算机系统概述

- 微型计算机的发展是根据，计算机微处理器的技术进行划分的

### 1.2 计算机系统层次结构

- 冯诺依曼架构：
  - 拥有存储单元，能够进行逻辑控制和计算
  - 硬件系统组成：
    - 输入设备
    - 运算器
      - 作用：执行算术运算和逻辑运算
      - 包含的硬件：
        - 累加器（ACC）：必存在的
        - 乘商寄存器（MQ）：必存在的
        - 操作数寄存器（X）：必存在的
        - 变址寄存器（IX）
        - 基址寄存器（BR）
        - 程序状态寄存器（PSW）：也叫标志寄存器
          - 用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出，有无产生进位或借位、结构是否为负等。
    - 存储器
      - 分为主存储器和辅存储器
      - 主存储器中
        - 地址寄存器（MAR）
        - 数据寄存器（MDR）
        - 上面两个都是CPU中，但是不属于控制器或者运算器中
    - 控制器
      - 程序计数器（PC）：用于执行当前欲执行指令的地址，可以自动加一形成下一条地址，与MAR之间有一条直接通路
      - 指令寄存器（IR）：用来存放当前指令，其内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用以分析指令并发出各种微操作命令序列：而地址码Ad(IR)送往MAR，用以取操作数
      - 控制单元（CU）：
    - 输出设备
- 计算机硬件能够执行的语言只有二进制机器码

### 1.3 计算机的性能指标

#### 1.3.1 计算机的主要性能指标

- 字长
- 数据通路带宽
- 主存容量
- 运算速度
  1. 吞吐量和响应时间
     1. 吞吐量
     2. 响应时间：包括CPU时间（运行一个程序所花费的时间），等待时间（）
  2. 主频和CPU时钟周期
  3. CPI，一条指令执行的时钟周期
  4. CPU执行时间
  5. MIPS，每秒执行多少百万指令
  6. MFLOPS、GFLOPS。。。
     1. MFLOPS：每秒执行多少百万浮点计算
- 基准程序

### 1.4 小结

## 第二章 数据的表示和运算

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换

#### 2.1.2 BCD码

- 8421码：常见的0000-1111表示十进制的1-16
- 余三码：4位二进制表示的数，最后两位余三才是实际的数
- 2421码：大于等于5的最高位为1，小于5的最高位为0

#### 2.1.3 定点数的编码表示

- 现代计算机中使用定点补码整数表示整数，定点原码小数表示浮点数的尾数部分。

**1. 原码**
$$
[x]_原 = 
\begin{cases}
x,\quad 1>x\geq 0\\
1-x=1+\lvert x \rvert, \quad 0\geq x>-1
\end{cases}
\tag{1}
$$

$$
\\
[x]_原 = 
\begin{cases}
0,x \quad 2^n>x\geq 0\\
2^n-x=2^n+\lvert x \rvert \quad 0\geq x>-2^n
\end{cases}
\tag{2}
$$



**2. 补码**
$$
[x]_补= 
\begin{cases}
x,\quad 1>x\geq 0\\
2+x=2-\lvert x \rvert, \quad 0\geq x>-1
\end{cases}
\tag{3}
$$

$$
\\
[x]_补 = 
\begin{cases}
0,x \quad 2^n>x\geq 0\\
2^{n+1}+x=2^{n+1}-\lvert x \rvert \quad 0\geq x \geq-2^n
\end{cases}
\tag{4}
$$

**3. 反码**

负数反码通过取反得到，不用末尾加一，如果加一就是负数的补码。正数反码的定义和相应的补码相同

**4. 移码**

移码表示浮点数的阶码，只能表示整数。定义
$$
[x]_移 = 2^n + x \quad \text{$2^n > x \geq -2^n $，机器字长为n+1}
$$
例如：正数x1 = +10101, x2 = -10101，字长为8位，则其移码表示：[x1]移 = 2^7 + 10101 = 10010101;[x2]移=2^7 + (-10101) = 0,1101011。

移码的特点：

1. 移码中零的表示唯一：[+0]移=2^n+0=[-0]移=2^n-0=2^n
2. 一个真值的移码和补码仅差一个符号位。
3. 移码全位0，对应的真值为-2^n，全为1是对应最大值为2^n-1

原码、补码、反码、移码总结：

1. 原码、补码、反码的符号位相同，正数的机器码相同
2. 原码、反码的表示在数轴上对称，两个都存在+0和-0
3. 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。
4. 整数的补码、移码的符号位相反，数值位相同。
5. 负数的反码、补码末位差1。
6. 原码容易判断大小。而负数的反码、补码可以通过：对于负数，数值部分越大，绝对值越小，真值越大（更靠近0）。

#### 2.1.4整数的表示

### 2.2 运算方法和运算电路

#### 2.2.1 基本运算部件

**1. 一位全加器**

和表达式：Si=Ai⨁Bi⨁C_(i-1)

进位表达式：Ci = AiBi + (Ai⨁Bi)C_(i-1)

**2. 串行进位加法器**

把n个全加器相连可得到n位加法器。称为串行进位加法器。，每级进位直接依赖于前一级的进位。

**3. 并行进位加法器**

令Gi = AiBi，Pi = Ai⨁Bi，全加器的进位表达式为：Ci = Gi+PiC_(i-1)，Ci只和Ai、Bi相关及最低进位C0相关，所以可以组成并行加法器

**4. 带标志加法器**

溢出标志的逻辑表达式：OF=Cn⨁C\_(n-1)；符号标志就是和的符号，SF = F\_(n-1)；零标志ZF=1当且仅当F=0；进位/借位标志CF=C\_(out)⨁C\_(in)，即当C\_(in)=0时，CF为进位C\_(out)，当C\_(in)=1时，CF为进位C\_(out)取反

#### 2.2.2 定点数的移位运算

**1. 算术移位**

|      | 码制             | 添补代码 |
| ---- | ---------------- | -------- |
| 正数 | 原码、反码、补码 | 0        |
| 负数 | 原码             | 0        |
| 负数 | 补码             | 左移填0  |
| 负数 | 补码             | 右移填1  |
| 负数 | 反码             | 1        |

**2. 逻辑移位**

左移，高位移丢，低位添0；逻辑右移时，低位移丢，高位填0

**3. 循环移位**

分为带进位标志位CF的循环移位和不带进位标志CF的循环移位。循环移位适合用于将数据的低字节数据和高字节数据互换。

#### 2.2.3 定点数的加减运算

- 零标识ZF=1表示结果F为0。不管对有符号还是无符号整数
- 溢出表示OF=1表示带符号整数运算时发生溢出。对于无符号整数运算，OF没有意义
- 符号标志SF表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义
- 进/借位标志CF表示无符号整数运算时的进位/借位，判断是否发生溢出。，对于带符号整数没有意义

#### 2.2.4 定点数的乘除运算 

**定点数乘除法原码运算**

**1. 定点数乘法原码运算**

**原码一位乘法**

[X]\_原 = xsx1x2...xn，[Y]\_ 原 = ysy1y2...yn，运算规则如下：

1. 被乘数和乘数均取绝对值参加运算，看作无符号数，符号位xs⨁ys
2. 部分积是乘法过程的中间结果，乘数的每一位yi乘以被乘数X后，将结果与前面所得结果结果累加，就是部分积，初值为0
3. 从乘数的最低位yn开始判断，若yn=1，则部分积加上被乘数|x|，然后右移一位；若yn = 0，则部分积加上0，则部分积加上0，然后右移一位。
4. 重复步骤3，判断n次

**2. 定点数除法原码运算**

1. 先用被除数减去除数（|X|-|Y|=|X|+[-Y]_补），当余数为正时，商上1，余数和尚左移一位再前去余数，当余数为负时，商上0，余数和商左移一位，加上除数。
2. 当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余数（余数与被除数同号）

**定点数乘除法补码运算**

[定点数乘除法资料](./CompositionPrinciples/定点数乘除法.pdf)

#### 2.2.5 C语言中的整数类型及类型转换

大字转小字，高位直接截断，保留低位

小字转大字，如果是无符号位，高位直接0填充，如果是有符号位，按照符号位是什么值就填充什么值。

#### 2.2.6 数据的存储和排列

大端方式是：一个类型的数据，按最高有效字节到最低有效字节的顺序存储数据，地址从低到高

小端方式是：一个类型的数据，按最低有效字节到最高有效字节的顺序存储数据，地址从低到高

边界对齐好处：提升指令效率，用空间换时间

### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

浮点数的表示格式：N=(-1)^S x M x R^E

S：表示符号位正负，M表示尾数（如果浮点数为32位，则有23位表示尾数，其中小数点左侧1隐藏了；如果浮点数为64位，则有52位表示尾数，其中小数点左侧1隐藏了）

R：表示基（比如2，4，8，10或16）

E：表示阶码（32位浮点数，8位阶码偏置值127，64位浮点数，11位阶码偏置值1023）

IEEE标准：规格化后32位浮点数：(-1)^S x 1.M x 2^(E-127)

IEEE标准：规格化后64位浮点数：(-1)^S x 1.M x 2^(E-1023)

**浮点数加减计算步骤**

1. 对阶：两操作数的小数点对齐，即使得两个浮点数的阶码相等。所以先求阶差，小阶向大阶看齐，阶码小的右移，阶码加一
2. 尾数求和
3. 规格化
4. 舍入：
   1. 0舍1入法
   2. 恒置1法
   3. 截断法
5. 溢出判断：正指数超出了最大允许值（127或1023）表示上溢，负指数小于最小允许值（-149或-1074）表示负溢出，在舍如过程可能会因为进位导致溢出，需要注意

#### 2.3.2 浮点数的加减运算

### 2.4 本章小结

## 第三章 存储系统

### 1.1 存储器概述

**1. 按在计算机中的作用（层次）分类**

1. 主存储器
2. 辅助存储器
3. 高速缓冲存储器，简称Cache，通常制在CPU中

**2. 按存储介质分类**

**3. 按存取方式分类**

1. 随机存储器（RAM）：任何一个存储单元都是随机存储，而且存取时间与物理位置无关
2. 只读存储器（ROM）：只能随机读取不能写入，断电也不会丢失内容。与随机存储器共同作为主存的一部分。
3. 串行访问存储器

**4. 按信息的可保存性分类**

1. 易失性存储器：RAM
2. 非易失性存储器：ROM等

### 1.2 主存储器

### 1.3 主存储器与CPU的连接

### 1.4 外部存储器

### 1.5 高速缓冲存储器

### 1.6 虚拟存储器

### 1.7 本章小结

## 第四章 指令系统

### 1.1 指令格式

### 1.1 指令的寻址方式

### 1.1 程序的机器级代码表示

### 1.1 CISC和RISC的基本概念

### 1.1 本章小结

## 第5章 中央处理器

## 第6章 总线

## 第7章 输入/输出系统