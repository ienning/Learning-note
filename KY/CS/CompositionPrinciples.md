[TOC]

# 计组原理

## 第一章

### 1.1 计算机系统概述

- 微型计算机的发展是根据，计算机微处理器的技术进行划分的

### 1.2 计算机系统层次结构

- 冯诺依曼架构：
  - 拥有存储单元，能够进行逻辑控制和计算
  - 硬件系统组成：
    - 输入设备
    - 运算器
      - 作用：执行算术运算和逻辑运算
      - 包含的硬件：
        - 累加器（ACC）：必存在的
        - 乘商寄存器（MQ）：必存在的
        - 操作数寄存器（X）：必存在的
        - 变址寄存器（IX）
        - 基址寄存器（BR）
        - 程序状态寄存器（PSW）：也叫标志寄存器
          - 用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出，有无产生进位或借位、结构是否为负等。
    - 存储器
      - 分为主存储器和辅存储器
      - 主存储器中
        - 地址寄存器（MAR）
        - 数据寄存器（MDR）
        - 上面两个都是CPU中，但是不属于控制器或者运算器中
    - 控制器
      - 程序计数器（PC）：用于执行当前欲执行指令的地址，可以自动加一形成下一条地址，与MAR之间有一条直接通路
      - 指令寄存器（IR）：用来存放当前指令，其内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用以分析指令并发出各种微操作命令序列：而地址码Ad(IR)送往MAR，用以取操作数
      - 控制单元（CU）：
    - 输出设备
- 计算机硬件能够执行的语言只有二进制机器码

### 1.3 计算机的性能指标

#### 1.3.1 计算机的主要性能指标

- 字长
- 数据通路带宽
- 主存容量
- 运算速度
  1. 吞吐量和响应时间
     1. 吞吐量
     2. 响应时间：包括CPU时间（运行一个程序所花费的时间），等待时间（）
  2. 主频和CPU时钟周期
  3. CPI，一条指令执行的时钟周期
  4. CPU执行时间
  5. MIPS，每秒执行多少百万指令
  6. MFLOPS、GFLOPS。。。
     1. MFLOPS：每秒执行多少百万浮点计算
- 基准程序

### 1.4 小结

## 第二章 数据的表示和运算

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换

#### 2.1.2 BCD码

- 8421码：常见的0000-1111表示十进制的1-16
- 余三码：4位二进制表示的数，最后两位余三才是实际的数
- 2421码：大于等于5的最高位为1，小于5的最高位为0

#### 2.1.3 定点数的编码表示

- 现代计算机中使用定点补码整数表示整数，定点原码小数表示浮点数的尾数部分。

**1. 原码**
$$
[x]_原 = 
\begin{cases}
x,\quad 1>x\geq 0\\
1-x=1+\lvert x \rvert, \quad 0\geq x>-1
\end{cases}
\tag{1}
$$

$$
\\
[x]_原 = 
\begin{cases}
0,x \quad 2^n>x\geq 0\\
2^n-x=2^n+\lvert x \rvert \quad 0\geq x>-2^n
\end{cases}
\tag{2}
$$



**2. 补码**
$$
[x]_补= 
\begin{cases}
x,\quad 1>x\geq 0\\
2+x=2-\lvert x \rvert, \quad 0\geq x>-1
\end{cases}
\tag{3}
$$

$$
\\
[x]_补 = 
\begin{cases}
0,x \quad 2^n>x\geq 0\\
2^{n+1}+x=2^{n+1}-\lvert x \rvert \quad 0\geq x \geq-2^n
\end{cases}
\tag{4}
$$

**3. 反码**

负数反码通过取反得到，不用末尾加一，如果加一就是负数的补码。正数反码的定义和相应的补码相同

**4. 移码**

移码表示浮点数的阶码，只能表示整数。定义
$$
[x]_移 = 2^n + x \quad \text{$2^n > x \geq -2^n $，机器字长为n+1}
$$
例如：正数x1 = +10101, x2 = -10101，字长为8位，则其移码表示：[x1]移 = 2^7 + 10101 = 10010101;[x2]移=2^7 + (-10101) = 0,1101011。

移码的特点：

1. 移码中零的表示唯一：[+0]移=2^n+0=[-0]移=2^n-0=2^n
2. 一个真值的移码和补码仅差一个符号位。
3. 移码全位0，对应的真值为-2^n，全为1是对应最大值为2^n-1

原码、补码、反码、移码总结：

1. 原码、补码、反码的符号位相同，正数的机器码相同
2. 原码、反码的表示在数轴上对称，两个都存在+0和-0
3. 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。
4. 整数的补码、移码的符号位相反，数值位相同。
5. 负数的反码、补码末位差1。
6. 原码容易判断大小。而负数的反码、补码可以通过：对于负数，数值部分越大，绝对值越小，真值越大（更靠近0）。

#### 2.1.4整数的表示

### 2.2 运算方法和运算电路

#### 2.2.1 基本运算部件

**1. 一位全加器**

和表达式：Si=Ai⨁Bi⨁C_(i-1)

进位表达式：Ci = AiBi + (Ai⨁Bi)C_(i-1)

**2. 串行进位加法器**

把n个全加器相连可得到n位加法器。称为串行进位加法器。，每级进位直接依赖于前一级的进位。

**3. 并行进位加法器**

令Gi = AiBi，Pi = Ai⨁Bi，全加器的进位表达式为：Ci = Gi+PiC_(i-1)，Ci只和Ai、Bi相关及最低进位C0相关，所以可以组成并行加法器

**4. 带标志加法器**

溢出标志的逻辑表达式：OF=Cn⨁C\_(n-1)；符号标志就是和的符号，SF = F\_(n-1)；零标志ZF=1当且仅当F=0；进位/借位标志CF=C\_(out)⨁C\_(in)，即当C\_(in)=0时，CF为进位C\_(out)，当C\_(in)=1时，CF为进位C\_(out)取反

#### 2.2.2 定点数的移位运算

**1. 算术移位**

|      | 码制             | 添补代码 |
| ---- | ---------------- | -------- |
| 正数 | 原码、反码、补码 | 0        |
| 负数 | 原码             | 0        |
| 负数 | 补码             | 左移填0  |
| 负数 | 补码             | 右移填1  |
| 负数 | 反码             | 1        |

**2. 逻辑移位**

左移，高位移丢，低位添0；逻辑右移时，低位移丢，高位填0

**3. 循环移位**

分为带进位标志位CF的循环移位和不带进位标志CF的循环移位。循环移位适合用于将数据的低字节数据和高字节数据互换。

#### 2.2.3 定点数的加减运算

- 零标识ZF=1表示结果F为0。不管对有符号还是无符号整数
- 溢出表示OF=1表示带符号整数运算时发生溢出。对于无符号整数运算，OF没有意义
- 符号标志SF表示结果的符号，即F的最高位。对于无符号数运算，SF没有意义
- 进/借位标志CF表示无符号整数运算时的进位/借位，判断是否发生溢出。，对于带符号整数没有意义

#### 2.2.4 定点数的乘除运算 

**定点数乘除法原码运算**

**1. 定点数乘法原码运算**

**原码一位乘法**

[X]\_原 = xsx1x2...xn，[Y]\_ 原 = ysy1y2...yn，运算规则如下：

1. 被乘数和乘数均取绝对值参加运算，看作无符号数，符号位xs⨁ys
2. 部分积是乘法过程的中间结果，乘数的每一位yi乘以被乘数X后，将结果与前面所得结果结果累加，就是部分积，初值为0
3. 从乘数的最低位yn开始判断，若yn=1，则部分积加上被乘数|x|，然后右移一位；若yn = 0，则部分积加上0，则部分积加上0，然后右移一位。
4. 重复步骤3，判断n次

**2. 定点数除法原码运算**

1. 先用被除数减去除数（|X|-|Y|=|X|+[-Y]_补），当余数为正时，商上1，余数和尚左移一位再前去余数，当余数为负时，商上0，余数和商左移一位，加上除数。
2. 当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余数（余数与被除数同号）

**定点数乘除法补码运算**

[定点数乘除法资料](./CompositionPrinciples/定点数乘除法.pdf)

#### 2.2.5 C语言中的整数类型及类型转换

大字转小字，高位直接截断，保留低位

小字转大字，如果是无符号位，高位直接0填充，如果是有符号位，按照符号位是什么值就填充什么值。

#### 2.2.6 数据的存储和排列

大端方式是：一个类型的数据，按最高有效字节到最低有效字节的顺序存储数据，地址从低到高

小端方式是：一个类型的数据，按最低有效字节到最高有效字节的顺序存储数据，地址从低到高

边界对齐好处：提升指令效率，用空间换时间

### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

浮点数的表示格式：N=(-1)^S x M x R^E

S：表示符号位正负，M表示尾数（如果浮点数为32位，则有23位表示尾数，其中小数点左侧1隐藏了；如果浮点数为64位，则有52位表示尾数，其中小数点左侧1隐藏了）

R：表示基（比如2，4，8，10或16）

E：表示阶码（32位浮点数，8位阶码偏置值127，64位浮点数，11位阶码偏置值1023）

IEEE标准：规格化后32位浮点数：(-1)^S x 1.M x 2^(E-127)

IEEE标准：规格化后64位浮点数：(-1)^S x 1.M x 2^(E-1023)

**浮点数加减计算步骤**

1. 对阶：两操作数的小数点对齐，即使得两个浮点数的阶码相等。所以先求阶差，小阶向大阶看齐，阶码小的右移，阶码加一
2. 尾数求和
3. 规格化
4. 舍入：
   1. 0舍1入法
   2. 恒置1法
   3. 截断法
5. 溢出判断：正指数超出了最大允许值（127或1023）表示上溢，负指数小于最小允许值（-149或-1074）表示负溢出，在舍如过程可能会因为进位导致溢出，需要注意

#### 2.3.2 浮点数的加减运算

### 2.4 本章小结

## 第三章 存储系统

### 3.1 存储器概述

#### 3.1.1 存储器分类

**1. 按在计算机中的作用（层次）分类**

1. 主存储器
2. 辅助存储器
3. 高速缓冲存储器，简称Cache，通常制在CPU中

**2. 按存储介质分类**

**3. 按存取方式分类**

1. 随机存储器（RAM）：任何一个存储单元都是随机存储，而且存取时间与物理位置无关
2. 只读存储器（ROM）：只能随机读取不能写入，断电也不会丢失内容。与随机存储器共同作为主存的一部分。
3. 串行访问存储器

**4. 按信息的可保存性分类**

1. 易失性存储器：RAM
2. 非易失性存储器：ROM等

#### 3.1.2 存储器的性能指标

存储器的性能指标主要包括三个：

1. 存储容量
2. 单位成本
3. 存储速度
   1. 存取时间：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间
   2. 存取周期：存取周期又称读写周期或访问周期，表示存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作之间所需要的最小时间间隔。
   3. 主存带宽：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒，字节/秒或者位/秒



#### 3.1.3 多级层次的存储系统

多级层次的存储系统用于解决大容量、高速度和低成本3个互相制约的矛盾。

CPU-寄存器-Cache-主存-磁盘-磁带或光盘。主存和Cache之间数据调动是通过硬件完成，对所有程序员透明，主存和辅存之间是数据调动是由硬件操作系统共同完成的，对应用程序透明。

### 3.2 主存储器

#### 3.2.1 SRAM芯片和DRAM芯片

SRAM（静态随机存储器）芯片：用于实现Cache，易失性存储器，非破坏性读出

DRAM（动态随机存储器）芯片：用于实现主存，易失性存储器：

1. 使用的是电荷刷新，刷新的方式：
   1. 集中刷新
   2. 分散刷新
   3. 异步刷新

**DRAM芯片的读写周期**

**存储芯片的内部结构**

1. 存储体
2. 地址译码器
3. I/O控制电路 
4. 片选控制信号
5. 读/写控制信号 

#### 3.2.2 只读存储器

ROM（只读存储器）优点：

1. 结构简单，所以位密度比可读写存储器高
2. 具有非易失性，所以可靠性高

**ROM类型**

根据工艺不同：

1. 掩模式只读存储器（MROM）：
   1. 特点：MROM内容由半导体厂商按用户提出的需求在芯片生产过程中直接写入，写入后任何人都无法改变其内容
   2. 优点：可靠性高，集成度高，价格便宜
   3. 缺点：灵活性差
2. 一次性可编程只读存储器（PROM）：
   1. 特点：允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变
   2. 优点：
   3. 缺点：
3. 可擦除可编程只读存储器（EPROM）：
   1. 特点：不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写，虽然可以读写，但是变成次数有限，且写入时间过长
4. Flash存储器：即可以在不加电的情况下
5. 固态硬盘（SSD）

#### 3.2.3 主存储器的基本组成

指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。

#### 3.2.4 多模块存储器

多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。

1. 单体多字存储器
   1. 特点：存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一个存储单元。
   2. 缺点：指令和数据在内存中必须是连续存放的，一旦遭遇转移指令，或操作数不能连续存放，这种方法的效果就不明显。
2. 多体并行存储器
   1. 特点：多提模块组成，每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作也能交叉工作。多体并行存储器分为高位交叉编址和地位交叉编址两种。
   2. 高位交叉编制（顺序方式）：
      1. 耗时公式：mT
   3. 地位交叉编址（交叉方式）：
      1. 耗时公式：T+(m-1)r

### 3.3 主存储器与CPU的连接

#### 3.3.1 连接原理

1. 主存储器通过数据总线、地址总线和控制总线与CPU连接
2. 数据总线的位数与工作频率的乘积正比于数据传输率
3. 地址总线的位数决定了可寻址的最大内存空间
4. 控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻

#### 3.3.2 主存容量的扩展

1. 位扩展法
2. 字扩展法
3. 字位扩展法

#### 3.3.3 存储芯片的地址分配和片选

1. 线选法：在片选的时候，某位选择后，其它位无法选择，某位生效后其它位无法生效
2. 译码片选法：通过译码器将多位组合而成选择某一片

#### 3.3.4 存储器与CPU的连接

1. 合理选择存储芯片
2. 地址线的连接
3. 数据线的连接
4. 读/写命令线的连接
5. 片选线的连接

### 3.4 外部存储器

#### 3.4.1 磁盘存储器

**1. 磁盘存储器**

1. 磁盘存储器的组成：磁盘驱动器、磁盘控制器和盘片
   1. 磁盘驱动器：核心部件是磁头组件和盘片组件
   2. 磁盘控制器：硬盘存储器和主机的接口
2. 存储区域：一块硬盘有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，即磁盘按块存取
   1. 磁头数：即记录面数，表示磁盘有多少个磁头
   2. 柱面数：表示磁盘每面盘片上有多少条磁道
   3. 扇区数：表示每条磁道上有多少扇区
3. 磁记录原理
   1. 原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作
   2. 编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁盘翻转状态的序列
   3. 磁记录方式：通过采用调频制（FM）和改进型调频制（MFM）的记录方式
4. 磁盘的性能指标：
   1. 记录密度：表示盘面单位面积记录的二进制信息量，以道密度、位密度和面密度表示
   2. 磁盘的容量：分为格式化容量和非格式容量，格式化容量小于非格式化容量
   3. 平均存取时间：平均存储时间由寻道时间（磁头移动到目的磁道的时间）、旋转延迟时间和传输时间三部分构成
      1. 注意：寻道时间中如果在磁道中寻找，需要添加单磁道的一半时间表示平均寻道耗时
   4. 数据传输率：磁盘每秒转速和每磁道容量的乘积为数据传输率
5. 磁盘地址：
   1. 驱动器号\-柱面（磁道）号\-盘面号\-扇区号
6. 磁盘工作过程：寻址、读盘、写盘，读写是串行的不能即读又写

**磁盘阵列**

RAID（独立冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性

1. RAID0：无冗余和无校验的磁盘阵列
2. RAID1：镜像磁盘阵列
3. RAID2：采用纠错的海明码的磁盘阵列
4. RAID3：位交叉奇偶校验的磁盘阵列
5. RAID4：块交叉奇偶校验的磁盘阵列
6. RAID5：无独立校验的奇偶校验磁盘阵列

#### 3.4.2 固态硬盘

固态硬盘（SSD）是基于一种闪存技术的存储器，和U盘没有本质区别、一个SSD有一个或多个闪存芯片和闪存翻译层组成。固态硬盘随机写慢，而且反复读写会对山村块磨损，比较机械硬盘，读写速度快，能耗低，抗震性好，安全性高。

### 3.5 高速缓冲存储器

#### 3.5.1 程序访问的局部性原理

程序访问的局部性原理包括时间局部性和空间局部性。

时间局部性：是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因程序中存在循环。

空间局部性：是指在最近的未来要用到的信息，很可能是与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起

高速缓存就是使用这个局部性原理。

#### 3.5.2 Cache的基本工作原理

Cache位于存储器层次结构的顶层，通常由SRAM构成。

Cache和主存间信息交换，Cache和主存都被划分为相等的块，Cache块又称为Cache行，每块由若干字节组成，块的长度称为块长（Cache 行长）。

命中率 
$$
\begin{cases}
H &= H_c/(N_c+N_m) & \text{命中率H，$N_c$是总命中次数，$N_m$是未命中次数} \\
T_a &= Ht_c+(1-H)t_m & \text{t_c命中Cache时间，T_m是未命中时的访问时间，1-H表示未命中率} 
\end{cases}
$$


#### 3.5.3 Cache和主存的映射方式

**1. 直接映射**

主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块被无条件地替换出去（无需使用替换算法）。直接映射简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，冲突概率最高，空间利用率低。

直接映射的关系定义：

Cache行号 = 主存块 mod Cache总行数

直接映射的地址结构：标记（有效位+内存块高位地址）+Cache行号（行内不存储）+块内地址

**2. 全相联映射**

主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取主存的哪一块，所以CPU访问时需要和所有Cache行的标记进行比较。优点是灵活冲突概率小，命中率高。缺点是速度较慢，成本高。

全相联映射的地址结构：标记（有效位+内存块高位地址）+ 块内地址

**3. 组相联映射**

将Cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式。

主存地址结构：标记 + cache组号 + 块内地址

#### 3.5.4 Cache中主存快的替换算法

常用的替换算法（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常（LFU）算法。

1. 随机算法：随机地确定替换的Cache块。实现简单，没有使用程序访问的局部性原理，命中率低
2. 先进先出算法：选择最早调入的行进行替换。
3. 近期最少使用算法：依据程序访问的局部性原理，选择近期内长久未访问过的Cache行作为替换的行，平均命中率比FIFO的高，是堆栈类算法。

#### 3.5.5 Cache写策略

Cache写命中有两种处理方法：

1. 全写法：当CPU对Cache写命中时，必须把数据同时写入Cache和内存，当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。
   1. 优点，实现简单，能随时保持主存数据的正确性。
   2. 缺点：增加了访问次数，降低了Cache的效率。
      1. 可以增加写缓冲，减少全写法直接写入内存的时间损耗，在CPU和主存之间增加一个写缓冲，CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。
2. 回写法：当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患，为了减少写回主存的开销，每个Cache行设置一个修改位（脏位）。若修改位为1，则说明对应Cache行中的块被修改过，替换时需要写回主存，若修改位为0，则说明对应Cache行的块未被修改过，替换时无需写回主存。

Cache写不命中的两个处理方法：

1. 写分配法：加载主存中的块到Cache中，然后更新这个Cache块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。
2. 非写分配法：只写入主存，不进行调块。

非写分配法通常与全写法合同，写分配法通常和回写法合用。

技术的发展需要将指令Cache和数据Cache分开设计。

- 统一Cache的优点是设计和实现相对简单，缺点是由于执行部件存储数据时，指令预取部件要从同一Cache读指令，会引发冲突。分离Cache结构可以解决这个问题，而且分离Cache能够充分利用分离的指令和数据的各自局部性来分别优化。

### 3.6 虚拟存储器

主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。

#### 3.6.1 虚拟存储器的基本概念

虚拟存储器将主存或辅存的地址空间统一编制，形成一个庞大的地址空间，这个空间内用户可以自由编程，而不必在乎主存容量和程序在主存中实际的存放位置。

虚拟存储器采用和Cache类似技术，将辅存中经常访问的数据副本放到主存。但是缺页（或段）而访问辅存的代价很大，需要提高命中率，因此虚拟存储器机制采用全相联映射，每个虚页面都可以存到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而在处理一致性问题时，采用回写法。

#### 3.6.2 页式虚拟存储器

页式虚拟存储器以页为基本单位。虚拟空间和主存空间都被划分成同样大小的页，主存的页成为实页、页框，虚存的页称为虚页。虚拟地址分为两个部分：虚页号和页内地址。虚拟地址到物理地址实际的转换是由页表实现的。页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。

**页表**

页表表头：有效位（对应页面是否在主存），修改位（脏位），引用位（配合替换策略使用），物理页或磁盘地址

CPU执行指令需要将虚拟地址转换为主存物理地址。

页式存储优缺点：

- 优点：页面长度固定，页表简单，调入方便
- 缺点：程序不可能刚好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。

**快表**

地址转换过程中，访问时，先访问一次主存去查页表，在访问主存才能取得数据。如果缺页了还要进行页面替换、页面修改等，因此采用虚拟存储器机制后，访问主存的次数更多了。

通过在高速缓存器中加入快表（TLB），用于存储频繁访问的页表项，提高效率。

快表通常采用全相联或组相连方式。

**具有TLB和Cache的多级存储系统**

在一个具有Cache和TLB的虚拟存储系统中，CPU一次访问可能涉及TLB、页表、Cache、主存和磁盘的访问。素以可能存在以下三种缺失情况

1. TLB缺失：要访问的页面的页表项不在TLB中，可由软件或硬件处理
2. Cache缺失：访问的主存块不在Cache中，由硬件处理
3. Page缺失：要访问的页面不在主存中，由软件处理

TLB缺失，需要访问一次主存，Cache缺失需要访问一次主存；TLB，Cache，Page都缺失需要至少访问两次主存，TLB，Cache缺失需要访问两次主存

#### 3.6.3 段式虚拟存储器

段式虚拟存储器中的段是按程序的逻辑结构划分的，每个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到物理地址之间的变换是由段表来实现的。

段表每行的构成：某个段对应的段号、装入位、段起点和段长等信息。

CPU根据段号和段表基地址拼接成对应的段表行。

主存物理实际地址 = 段表行中读取的段的起始地址 + 段内地址

优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享

缺点：长度可变，分配不方便，容易在段间留下碎片，不好利用容易造成浪费。

#### 3.6.4 段页式虚拟存储器

把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。

虚地址构成：段号 + 段内页号 + 页内地址

优点：兼具页式虚拟存储器和段式虚拟存储器优点

缺点：地址变换过程中，需要两次查表，系统开销大。

#### 3.6.5 虚拟存储器与Cache比较

**相同点**

1. 最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度
2. 都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大
3. 都有地址映射、替换算法、更新策略等问题
4. 依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中。

**不同点**

1. Cache主要解决系统速度，而虚拟内存主要解决主存容量问题
2. Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明
3. 对于不命中性能影响，因为CPU速度是约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大
4. CPU与Cache和主存都建立了直接访问的通路，而辅存于CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。

### 3.7 本章小结

## 第四章 指令系统

### 1.1 指令格式

### 1.1 指令的寻址方式

### 1.1 程序的机器级代码表示

### 1.1 CISC和RISC的基本概念

### 1.1 本章小结

## 第5章 中央处理器

## 第6章 总线

## 第7章 输入/输出系统

